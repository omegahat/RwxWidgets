<?xml version="1.0"?>

<article xmlns:r="http://www.r-project.org"
         xmlns:wx="http://www.wxwidgets.org"
         xmlns:sh="http://www.shell.org"
         xmlns:cpp="http://www.cplusplus.org"
         xmlns:rwx="http://www.omegahat.org/RwxWidgets">

<para>
 On my Linux box running as a VM on a MacBook Pro, this used to take
 about 5 and 1/2 minutes to run currently.  It gives many warnings
 but these are mainly for me and should not concern the user excessively.
</para>
<para>
 Run-times have been dramatically improved and then slowed down again.
 Hashing the DefinitionContainer  and using exists() at different levels
 yielded a dramatic improvement (72 minutes down to 5 minutes). More features
 have brought this up to 8.
</para>


<para>
 The resulting code gives two warnings about deprecated routines - GetItemSpacing and ParseWildcard.
</para>

<para>
 Fixed
  repeats for wxBitmapButtonBase
     these are the ones that return a const
  Identify abstract classes.
      wxChoiceBase() and wxControlWithItems()
</para>

<para>
 Find out which wx/ files are not included that we need
 splitter.h is one.
 Use GCC to calculate the dependencies and compare the list
 to the entire contents of the top-level directory of the include
 area and the generic/ and gtk/ specific directories.
</para>

<r:code id="run">
library(RGCCTranslationUnit)
autoGenerateDir = "."  # should be in RwxWidgets/autoGenerate
</r:code>

<r:code>
if(!exists("wxResolvedMethods")) {

sys = parseTU(paste(autoGenerateDir, "system.cpp.tu", sep = .Platform$file.sep))

sysDeclarations = getAllDeclarations(sys)
sysClasses = getClassNodes(sys)
</r:code>


<r:code id="run">
targetFiles = basename(list.files("/usr/local/include/wx-2.8/wx", recursive = TRUE))
</r:code>

If we use isSourceFile, then we don't need to trim the .h's off.
<r:code eval="false">
targetFiles = gsub("\\.[^\\.]+$", "", targetFiles)
</r:code>

<para>
Make certain we can load the GCC TranslationUnit parser.
<r:code id="run">
library(RSPerl)
if(length(grep("linux", R.Version()$platform)))
  xsSupport(c("IO", "Fcntl", "POSIX", "Socket"))
</r:code>
</para>

<r:code id="run">
wxTUFile = paste(autoGenerateDir, "wx.cpp.t00.tu", sep = .Platform$file.sep)
wxTUFile = "wx.cpp.t00.tu"
tu = parseTU(wxTUFile) # use the perl parser 
</r:code>


<ignore>
<r:code>
if(FALSE) {  # skip all of this.
if(FALSE) {
   # This version uses the files to filter. 
  wxDeclarations = getAllDeclarations(tu, targets)
} else {
   # This one matches against the ones in 
  wxAllDeclarations = getAllDeclarations(tu)
  wxDeclarations = wxAllDeclarations[ !(names(wxAllDeclarations) %in% names(sysDeclarations)) ]
}
}
</r:code>
</ignore>


<para>
We next get the class definitions.
This can take some time so we investigate how to speed it up.
We use isSourceFile to do the comparison of the name of the source file of
the class declaration with our list of target files.
<note><para>The timings were done on a smaller TU file</para></note>
<r:code eval="false">
<![CDATA[
system.time(wxClasses <- getClassNodes(tu, targetFiles, validateSource = isSourceFile))
]]>
<r:output>
   user  system elapsed 
154.177   0.036 154.334 
</r:output>
</r:code>
Using the current default function <r:func>checkSource</r:func>
(which doesn't actually work properly!), we get 
<r:code eval="false">
<![CDATA[
 system.time(tmp <- getClassNodes(tu, targetFiles))
]]>
<r:output>
   user  system elapsed 
176.323   2.828 179.220 
</r:output>
</r:code>
And a final approach is to put the names of the target files
into  a hash table and use exists on that.
This is essentially what the isSourceFile does so it doesn't save 
<r:code><![CDATA[
e = new.env(hash = TRUE, emptyenv())
sapply(targetFiles, assign, 1, e)
system.time(tmp2 <- getClassNodes(tu, targetFiles, validateSource = function(x, files) exists(gsub(":[0-9]+$", "", x), e, inherits = FALSE)))
]]><r:output>
   user  system elapsed 
153.426   0.012 153.506 
</r:output>
</r:code>

And comparing the results, 
<r:code>
setdiff(names(wxClasses), names(tmp))
setdiff(names(tmp), names(wxClasses))
</r:code>
</para>
<para>
To gain any significant speedup, we need to avoid iterating over the
entire array of nodes.  After all, there are approximately half a
million of them.  So we change the Perl parser so that as it processes
each node during the parsefile method, it stores any record_type node
in an additional array (i.e. as well as the main array). Then, we can
access just the record types directly from this secondary array and we
get immense speedup.
Timing this on the larger TU file (i.e. bigger than the one used
for the timings above), we have
<r:code>
<![CDATA[
system.time(wxClasses <- getClassNodes(tu, targetFiles, validateSource = isSourceFile))
]]>
<r:output>
Number of nodes 2910
   user  system elapsed 
  3.360   0.016   3.377 
</r:output>
</r:code>
So we have moved from 500 seconds to 3.5!
<note><para>
Problems on Linux under Paralles running g++ 4.2.1.
This returns a list with only 2 elements:
"auto_ptr&lt;_Tp&gt;" and "auto_ptr_ref&lt;_Tp1&gt;"
</para></note>
</para>

<r:code id="run">
wxClasses = getClassNodes(tu, targetFiles, validateSource = isSourceFile)
</r:code>

<para>
There may be duplicates coming from system classes that we didn't
eliminate with the file filtering (due to duplicate file names in the
system include directories and wx) In fact, what we end up with are
mostly entries named iterator, const_iterator, reverse_iterator,
Iterator, etc.  These are all different nodes, but are essentially not
of interest to us for the most part at present.  There are some named
Node and Insert_Result which we need to look at more closely.  Both
are created as part of a HashMap macro expansion.  We should be
filtering these out as they have a different scope (the "scpe"
attribute).  Arguably, this should be done in the RGCCTranslationUnit
package itself in the call to getClassNodes.
<note>Put this into RGCCTranslationUnit</note>
<r:code id="run">
wxClasses = wxClasses[
                sapply(wxClasses,
                        function(node) {
			   if(!("scpe" %in% names(node)))
			      return(TRUE)
			     
                           scope = node[["scpe", convert = FALSE]]
                             # if it is a namespace_decl node, then its okay.
			   inherits(scope, "GCC::Node::namespace_decl")
                        })]
</r:code>
Then, all the duplicates disappear.
<r:code id="run">
any(duplicated(names(wxClasses)))
wxClasses = wxClasses[ !(names(wxClasses) %in% names(sysClasses))]
</r:code>

</para>


<para>
To find out the names of the classes that are not obviously
wxWidgets-related, we can use the following
<r:code eval="false">
sort(unique(names(wxClasses)[-grep("^(\\.|_?wx|_WX)", names(wxClasses))]))
</r:code>
The \\. rules out the static classes (which have names like
"._143").
</para>
<para>
We are left with 23 (on my Linux box running 2.6.3).  
<r:output>
 [1] "Buffer"                           "CachedAttr"                      
 [3] "cmsghdr"                          "const_iterator"                  
 [5] "const_reverse_iterator"           "_DATE_STRUCT"                    
 [7] "DATE_STRUCT"                      "EventTypeTable"                  
 [9] "__exception"                      "__fsid_t"                        
[11] "fsid_t"                           "GAddress"                        
[13] "_GAddress"                        "GenericKey"                      
[15] "GSocket"                          "GSocketGUIFunctionsTable"        
[17] "GSocketGUIFunctionsTableConcrete" "HSVValue"                        
[19] "Insert_Result"                    "iterator"                        
[21] "Iterator"                         "MessageParameters"               
[23] "msghdr"                           "Node"                            
[25] "reverse_iterator"                 "RGBValue"                        
[27] "sockaddr"                         "_TIMESTAMP_STRUCT"               
[29] "TIMESTAMP_STRUCT"                 "_TIME_STRUCT"                    
[31] "TIME_STRUCT"                      "TimeZone"                        
[33] "Tm"                              
</r:output>
The ones that seem to warrant more attention for being able to use the
GUI part of the wxWidgets library from R are RGBValue, HSVValue,
Insert_Result, EventTypeTable MessageParameters, Node, TimeZone, GIFImage, GenericKey. 
</para>


<para>
We'll deal with some of the classes by hand and so ignore them.
<r:code id="run">
ignore =
  list(classes = c("_wxHashTable_NodeBase", "wxDllLoader",
                   "wxStringBase", "wxString", "wxStringBuffer",
                   "wxMBConv", "wxCharBuffer", "wxCSConv",
                   "wxArrayString",  "wxArrayShort", "wxArrayLong", 
                   "wxArrayPtr", "wxArrayPtrVoid", "wxWCharBuffer",
                   "wx__ZipEntryList",
                   "wxObjectList"))


if(length(ignore$classes)) 
  wxClasses = wxClasses [ !( names(wxClasses) %in% ignore$classes) ]

 #ends with List
wxClasses = wxClasses [ - grep("List$", names(wxClasses) ) ]
</r:code>
</para>

<section>
<title>Examining a class: wxSlider</title>
<para>
Let's look at the wxSlider class as an example before
working with all the classes generally.
We start by finding the class hierarchy for this.
<r:code>
slider = wxClasses[[ "wxSlider" ]]

getBaseClasses(slider, recursive = TRUE)
<r:output>
         475794           16291           18625            7157            8565 
 "wxSliderBase"     "wxControl" "wxControlBase"      "wxWindow"  "wxWindowBase" 
           7585             624 
 "wxEvtHandler"      "wxObject" 
</r:output>
</r:code>
This shows us what class wxSlider is derived from, and what each of those 
parent classes themselves are derived from.  The 
numbers that appear as names identify the nodes for those class definitions.
But, of course, we already have the nodes in our list <r:var>wxClasses</r:var>.
</para>

<para>
Next, let's get the methods for this wxSlider class.
<r:code>
m = getClassMethods(slider)
</r:code>
We can control whether we get just the public methods or also the protected ones.
Eventhough we cannot call the protected methods from R,
we do use the protected methods in our code generation.
We create a C++ class  that extends wxSlider and whose methods can be 
(optionally) implemented by R functions. And so we want to be able to implement
these protected methods  from within this derived class.
<r:code>
names(m)
<r:output>
 [1] "wxSlider"                  "wxSlider"                 
 [3] "Create"                    "GetValue"                 
 [5] "SetValue"                  "SetRange"                 
 [7] "GetMin"                    "GetMax"                   
 [9] "SetLineSize"               "SetPageSize"              
[11] "GetLineSize"               "GetPageSize"              
[13] "SetThumbLength"            "GetThumbLength"           
[15] "GetClassDefaultAttributes" "IsOwnGtkWindow"           
[17] "GtkDisableEvents"          "GtkEnableEvents"          
[19] "GetClassInfo"              "wxCreateObject"           
</r:output>
</r:code>
These are basic descriptions of the methods that refer to other nodes in the
TU list. We need resolve the types and bring the description into an R object.
We do this with <r:func>resolveType</r:func>.
Let's create a DefinitionContainer to manage the resolution of the types.
This saves time as we don't end up resolving the same node multiple times.
<r:code>
types = DefinitionContainer()
rm = resolveType(m, tu, types)
</r:code>
Now we have "complete" descriptions of the methods.
Let's look at the constuctors.
These are the methods with the name wxSlider, the same as the class.
Alternatively, we can look at the class of the resolved methods.
<r:code>
sapply(rm, class)
</r:code>
and the first two are ResolvedNativeClassConstructor.
We can examine the parameters of each with
<r:code>
sapply(rm[1:2], function(x) length(x$parameters))
wxSlider wxSlider 
       1       11 
</r:code>
Each has an implicit 'this' object as a parameter.
This is not supplied  by the programmer but by the compiler.
As a result, we see that we have the default constructor
with no explicit parameters and 
one with 10 parameters.
We'll look at the latter, number 2.
We can find the names of the parameters with
<r:code>
names(rm[[2]]$parameters)
<r:output>
 [1] "this"      "parent"    "id"        "value"     "minValue"  "maxValue" 
 [7] "pos"       "size"      "style"     "validator" "name"     
</r:output>
</r:code>
The types are also available. A simple way to get at these is
<r:code>
sapply(rm[[2]]$parameters[-1], function(x) x$type@name)
       parent        id.int         value      minValue      maxValue 
           NA  "wxWindowID"         "int"         "int"         "int" 
          pos          size         style     validator          name 
    "wxPoint"      "wxSize"    "long int" "wxValidator"    "wxString" 
</r:code>
We see all but the first which is the parameter parent which appears as an <r:NA/>.
We can look at this closer with 
<r:code>
class(rm[[2]]$parameters[[2]]$type)
<r:output>
[1] "PointerType"
attr(,"package")
[1] "RGCCTranslationUnit"
</r:output>
</r:code>
And the name of the type to which this points
is a 
<r:code>
 rm[[2]]$parameters[[2]]$type@typeName
<r:output>
[1] "wxWindow"
</r:output>
</r:code>
The return type of the constructor is the new instance of the
class.
</para>

<para>
Let's look at the SetRange method and find out about its paramters
<r:code>
sapply(rm[["SetRange"]]$parameters, function(x) x$type@name)
</r:code>
So we see there are three - the implicit 'this'
and two integer values.
There is no return value as the following command and output displays:
<r:code>
class(rm[["SetRange"]]$returnType)
<r:output>
[1] "voidType"
attr(,"package")
[1] "RGCCTranslationUnit"
</r:output>
</r:code>
</para>

<para>
We might also take a look at another class, say wxGridBagSizer.
<r:code>
m = getClassMethods(wxClasses[["wxGridBagSizer"]])
rm = resolveType(m, tu, types)
</r:code>
Are there any overloaded methods within this class?
<r:code>
unique(names(rm)[duplicated(names(rm))])
<r:output>
[1] "Add"                  "GetItemPosition"      "SetItemPosition"     
[4] "GetItemSpan"          "SetItemSpan"          "FindItem"            
[7] "CheckForIntersection" "Insert"               "Prepend"             
</r:output>
</r:code>
If we focus on the Add method, we can find out how many parameters
each has.
<r:code>
apply(rm[ names(rm) == "Add" ], function(x) length(x$parameters))
<r:output>
Add Add Add Add Add Add Add Add 
  7   7   8   2   6   6   7   2 
</r:output>
</r:code>
And we can see what the names are for the longest one
as we will use this in creating the methods for the overloaded
values.
</para>

</section>

<para>
# Not used yet.
<r:code id="run">
renameFunctions = c("assign" = "Assign")

#
TypeMap =
  typeMap("wxChar *" = list( #target = new("PointerType", name = "wxChar", depth = as.integer(1)),
               coerceRValue = "as.character",
               convertRValue = "RtowxChar",
               convertValueToR = "wxCharToR"
           ),
         "wxString" = list( #target = new("PointerType", name = "wxChar", depth = as.integer(1)),
               coerceRValue = "as.character",
               convertRValue = "R_to_wxString",
               convertValueToR = function(name, ...) { cat("converting wxString\n"); paste("wxStringToR(", name, ")")}
           ),          
      list(target = new("C++ReferenceType", name = "wxString", type = new("C++ClassDefinition", name = "wxString")),
           coerceRValue = "as.character",
           convertRValue = "R_from_wxString",
           convertValueToR = "R_as_wxString"
          ),
      list(target = new("PointerType", name = "wchar_t", depth = as.integer(1)),
           coerceRValue = "as.character",
           convertRValue = "to_wchar_t_from_R",
           convertValueToR = "wchar_t_ptr_to_R"
          ),          
      "wchar_t *" = list(coerceRValue = "as.character",
                         convertRValue = "to_wchar_t_from_R",
                         convertValueToR = "wchar_t_ptr_to_R")
   )

#  ,  .default = list(convertValueToR = function(name, parm, parameters, typeMap) {        })
</r:code>
</para>

<para>
These need to change.
If we are dealing with an instance which has wxObject as an ancestor class,
then use R_make_wxWidget_Ref. Otherwise, use R_make_wx_Ref().

<r:code id="run">
# our own local version.
createNativeReference =
  function(name, parm, typeName) {
       paste("R_make_wxWidget_Ref(", name, ', "', typeName, '");', sep = "")
 }
# assignInNamespace("createNativeReference", createNativeReference , "RGCCTranslationUnit")

derefNativeReference =
function(name, type, refName) {
   if(is(type, "PointerType"))
     type = type@type
  
  if(is(type, "TypeDefinition")) {
    type = type@name
  }
  
  paste("R_get_wxWidget_Ref(", name, ', "', type, '")', sep = "")
}
</r:code>
</para>


<para>

Here we specify information we know about out arguments.
This needs a lot of work.
<r:code id="run">

outArgs =
  list("SplitPath" = c(class = "wxFileName", param = "hasExt", type = "scalar", style = "out"),
       "PositionToXY" = c(class = "wxTextCtrl", param = list("x" = "scalar",
                                                             "y" = "scalar"), style = "out")
      )
</r:code>
</para>


<section>
<title>The wxWindow class hierarchy</title>
<para>
For expedience (because resolving ALL of the classes takes so
long<foonote><para> We have dramatically sped this up by avoiding
massive memory buildup and thrashing.  We now return a
<r:class>ResolvedTypeReference</r:class> object when we resolve a C++
class definition and this avoids making a very large number of copies
of the entire C++ class description. 
So we can now deal with 
 </para></foonote>), we will look
just at those classes that extend wxObject.  We get this subset and
then
<r:code id="run">
wxClasses = derivedFrom(wxClasses, "wxObject", value = TRUE)
types = DefinitionContainer(tu)
wxMethods = lapply(wxClasses, getClassMethods)
wxRMethods = lapply(wxMethods, function(x) {print(names(x)[1]); resolveType(x, tu, types)})
</r:code>
How many types were resolved?
<r:code>
length(objects(types)[ - grep("^[0-9]", objects(types)) ] )
<r:output>
[1] 1707
</r:output>
</r:code>
We eliminated the entries corresponding to the nodes which are
the ones that start with a digit and just focus on the ones
with regular names.
</para>

<para>
Now, let's generate the bindings for one of these classes,
say wxHtmlWindow.
<r:code>
html = wxRMethods[["wxHtmlWindow"]]
</r:code>
We can compare the public methods to those in the wxWidgets documentation.
<r:code>
table(names(html[ sapply(html, function(x) x$access == "public") ]))
<r:output>

                AddFilter        AddGlobalProcessor              AddProcessor 
                        1                         1                         1 
             AppendToPage              __base_dtor               __comp_dtor  
                        1                         1                         1 
                   Create          __deleting_dtor               GetClassInfo 
                        1                         1                         1 
GetInternalRepresentation           GetOpenedAnchor             GetOpenedPage 
                        1                         1                         1 
       GetOpenedPageTitle                 GetParser           GetRelatedFrame 
                        1                         1                         1 
              HistoryBack            HistoryCanBack         HistoryCanForward 
                        1                         1                         1 
             HistoryClear            HistoryForward                  LoadFile 
                        1                         1                         1 
                 LoadPage             OnCellClicked          OnCellMouseHover 
                        1                         1                         1 
            OnLinkClicked              OnOpeningURL                OnSetTitle 
                        1                         1                         1 
        ReadCustomization                 SelectAll           SelectionToText 
                        1                         1                         1 
               SelectLine                SelectWord        SetBackgroundImage 
                        1                         1                         1 
               SetBorders                  SetFonts                   SetPage 
                        1                         1                         1 
          SetRelatedFrame       SetRelatedStatusBar          SetStandardFonts 
                        1                         1                         1 
                   ToText        WriteCustomization            wxCreateObject 
                        1                         1                         1 
             wxHtmlWindow 
                        3 
</r:output>
</r:code>
We see that AddGlobalProcessor, AddProcessor, Create, GetParser,
SetBackgroundImage, SetStandardFonts, wxCreateObject and the
destructors (__....dtor) are listed here but not in the documentation.
GetClassInfo and wxCreateObject are general functions for wx
classes. The former returns meta-data that can be used at run-time to
find out about the class and the latter allows us to create an
instance of this class at run time.  These are legitimate, public
methods that we can call.  Why they are not in the documentation is
another matter.



</para>
<para>
<r:code>
tt = createClassBindings(wxClasses[["wxHtmlWindow"]], tu,  "wxHtmlWindow", types, resolvedMethods = html)
</r:code>

We can do this generally for the entire collection with
<r:code>
helperInfo = new.env(TRUE)
class(helperInfo) = "HelpInfo"

code = lapply(names(wxClasses), function(i) createClassBindings(wxClasses[[i]], tu, i, types, resolvedMethods = wxRMethods[[i]]))



#                                             polymorphicNames = names(polymorphic),
classBindings = lapply(names(winClasses),  
                       function(n) 
                         createClassBindings(wxClasses[[n]], tu, n, types = types,
                                             abstract = abstractClasses,
                                             resolvedMethods = wxRMethods[[ n]],
                                             methods = wxMethods[[ n ]],
                                             typeMap = TypeMap, 
                                             generateOverloaded = FALSE,
                                             helperInfo = helperInfo
                                            ))
names(classBindings) = names(winClasses)
</r:code>


<r:code>
defs = unlist(lapply(classBindings, function(x) x$classDefinitions), recursive = FALSE)
names(defs) = gsub(".*\\.", "", names(defs))
</r:code>
</para>
</section>

<ignore>
This just isn't used and is unnecessary.
<r:code>

# Find the descendants of wxWindow.
#XXX Why only wxWindow? What about the other classes?
#XXX what about the other classes, at least wxObject.
#XXX Is this actually filtering correctly.

isDerivedFromWxObject = isDerivedFrom(wxClasses, "wxWindow")
widgetClasses = names(isDerivedFromWxObject[isDerivedFromWxObject])
# are any names duplicated - perhaps because of nesting?
if(any(duplicated(names(isDerivedFromWxObject[isDerivedFromWxObject]))))
  warning("Duplicated names")


# Have to add "wxWindow" back to this unless we do
# names(wxClasses)[sapply(wxClasses,
#                          function(n)
#                            "wxWindow" %in% c(getNodeName(tu[[n]]), getBaseClasses(tu[[n]], recursive = TRUE))])
#
</r:code>
</ignore>

<para>
<r:code>
cat("Starting the processing of the nodes\n")
</r:code>

<r:code>
</r:code>


Now we fetch the methods for each of the classes.
<r:code>
widgetClasses = names(wxClasses)
wxMethods = lapply(wxClasses[widgetClasses], getClassMethods)   
</r:code>

</para>
<para>
And now get ready to generate the bindings, managing the types across methods and classes to avoid 
resolving the same type multiple times.
</para>

<para>
Note that by using exists() rather than  id %in% objects()
we reduced the run time of this script (Sep 29 06) by a factor of 5!!!
Profiling identified the objects() call as the primary time consumer and
changing just 2 places in the code yielded changes in run time from
3769 seconds to 718.
Go this down further by using hashed environments in the DefinitionContainer
for managing the .resolved and .pending
And a little more by using registered symbols in RSPerl via useDynLib().
</para> 
<r:code>

<![CDATA[

types = DefinitionContainer(nodes = tu, verbose = FALSE)

abstractClasses = c("wxChoiceBase", "wxControlWithItems",
                    "wxHtmlWinTagHandler", "wxDC", "wxListBase"
# These ones are detected because of pure methods
#                     , "wxStatusBarBase", "wxNotebookBase",   "wxTopLevelWindowBase"
                   )

resolve.time = system.time(
            wxResolvedMethods <- lapply(wxMethods ,
                             function(m) {
                               lapply(m, resolveType, tu, types)
                             })
            )
]]>

</r:code>

<para>
Next, we attempt to determine  which classes have no copy constructor.
<r:code>
wxIncludeDir = "/usr/local/include/wx-2.6"
classes = system(paste("grep -r 'DECLARE_NO_COPY_CLASS(' ", wxIncludeDir), intern = TRUE)
classes = gsub(".*:[ ]+DECLARE_NO_COPY_CLASS\\((.*)\\)$", "\\1", classes)
noCopyClasses = classes[ - grep(":", classes) ]
</r:code>
</para>


<r:code>
# See removeDuplicates in write.R

if(FALSE) 
wxResolvedMethods = lapply(names(wxResolvedMethods),
                        function(className) {
                           m = wxResolvedMethods[[className]]
                           ids = sapply(m, function(method) NativeMethodName(method$name, className, TRUE, method$parameters))
 # Is this necessary.                                
                           m[!duplicated(ids)]
                         })
names(wxResolvedMethods) = widgetClasses

}  # if !exists("wxResolvedMethods")
</r:code>

<para>
 determine which methods are overloaded.
<fix>add top-level routines and check for overloading with these.</fix>
<r:code>
polymorphic = table(unlist(lapply(wxMethods, names)))
polymorphic = polymorphic[polymorphic > 1]
</r:code>

<r:code>
helperInfo = new.env(TRUE)
class(helperInfo) = "HelpInfo"

classBindings = lapply(widgetClasses,  
                       function(n)
                         createClassBindings(tu[[ wxClasses[n] ]], tu, n, types = types,
                                             polymorphicNames = names(polymorphic),
                                             abstract = abstractClasses,
                                             resolvedMethods = wxResolvedMethods[[ n ]],
                                             methods = wxMethods[[ n ]],
                                             typeMap = TypeMap, generateOverloaded = FALSE,
                                             helperInfo = helperInfo
                                            ))
names(classBindings) = widgetClasses
</r:code>
</para>

<para>
Remove any empty entries. These show us objects of
class list and there is no writeCode method.
<r:code>
idx = which(sapply(classBindings, length) == 0)
if(length(idx))
  classBindings = classBindings[ - idx ] 
</r:code>
</para>

<para>
In this fragment, we deal with top-level variables that we will need
in the interface.  We work with the constant variables (i.e. the
immutables), the enumerations, the pre-processor defines and finally
the regular top-level variables whose values can change during the
R/wxWidgets session.
<r:frag id="globals"><![CDATA[
globalConstants = computeGlobalConstants(tu, files = targetFiles)
# Use wxAll instead of dynamically creating this list. But leave here for now.
# includes = expandConstantIncludeFileNames(globalConstants$filenames, "/usr/local/include/wx-2.8/wx")
writeCode(globalConstants, "native", 
           file = file.path(autoGenerateDir, "../inst/src/wxConstants.cpp"),
           includes = '"wxAll.h"'
          )

]]></r:frag>



We can perform some reduction on the names of some of the events.
See also eventMappings.R.
We know that we that EVT_RADIOBOX maps to wxEVT_COMMAND_RADIOBOX_SELECTED.
We can look for all global variables that match
wxEVT_COMMAND_.*_SELECTED.
We get 
<r:code eval='false'>
grep("wxEVT_COMMAND_.*_SELECTED", names(globalConstants$cmds), value = TRUE)
<r:output>
[1] "wxEVT_COMMAND_CHOICE_SELECTED"      "wxEVT_COMMAND_COMBOBOX_SELECTED"   
[3] "wxEVT_COMMAND_LISTBOX_SELECTED"     "wxEVT_COMMAND_LIST_ITEM_SELECTED"  
[5] "wxEVT_COMMAND_MENU_SELECTED"        "wxEVT_COMMAND_RADIOBOX_SELECTED"   
[7] "wxEVT_COMMAND_RADIOBUTTON_SELECTED" "wxEVT_COMMAND_VLBOX_SELECTED"      
</r:output>
</r:code>
And so we could reduce these to EVT_CHOICE,  EVT_COMBOBOX,
EVT_LISTBOX, , EVT_MENU, EVT_RADIOBOX, EVT_RADIOBUTTON, EVT_VLBOX
</para>
<para>
We can do the same for CLICKED events.
</para>
<para>
We can generate the mapping code with the command
<r:code eval='not yet'>
tmp = gsub("wxEVT_COMMAND_(.*)_(SELECTED|CLICKED)", "EVT_\\1", 
            grep("wxEVT_COMMAND_.*_(SELECTED|CLICKED)", names(globalConstants$cmds), value = TRUE))

paste(tmp, grep("wxEVT_COMMAND_.*_(SELECTED|CLICKED)", names(globalConstants$cmds), value = TRUE), sep = " = ")
</r:code>
</para>
<para>
Similarly, we can access
EVT_SCROLLWIN events with
<r:code>
tmp = grep("wxEVT_SCROLLWIN", names(globalConstants$cmds), value = TRUE)
paste(gsub("^wx", "", tmp), tmp, sep = " = ")
</r:code>
although this includes wxEVT_SCROLLWIN_THUMBRELEASE and THUMBTRACK.

</para>

<para>
When dealing with enumerations, we have added some facilities to try 
to guess whether the enumeration is intended for bitwise OR'ing.
The guessing mechanism is heuristic and provided by the
function <r:func>guessBitwiseEnum</r:func>
which may call <r:func>findBitwiseFunctionOf</r:func>.
This attempts to use the bitops and Combinations packages.
If we look at the ones that it is not "certain" of, we get
<r:code>
edefs = lapply(getEnumerations(tu), resolveType, tu)
w = sapply(edefs, function(x) { guessBitwiseEnum(x@values, x@name)})
names(edefs[is.na(w)])
<r:output>
 [1] "NameFlags"         "._109"             "._106"            
 [4] "._17"              "._16"              "._95"             
 [7] "._7"               "wxLocaleInitFlags" "._129"            
[10] "._167"             "wxSystemFeature"   "._178"            
[13] "wxSplitMode"       "._149"             "._151"            
[16] "wxSplitMode"       "wxGeometryCentre" 
</r:output>
</r:code>
The oddly named ones of the form ._digit... are
anonymous enumerations. Some of them are within
classes and not necessarily of interest for us.
If we look at the number of values in each of these enumerations,
we see that most have only 2:
<r:code>
table(sapply(edefs[is.na(w)], function(x) length(x@values)))
<r:output>
 2  3 
16  1 
</r:output>
</r:code>
The element with 3 values is
<r:code>
edefs[is.na(w)][sapply(edefs[is.na(w)], function(x) length(x@values) == 3)][[1]]@values
<r:output>
      wxTEMPLATE_VISIBLE     wxTEMPLATE_INVISIBLE wxDEFAULT_TEMPLATE_FLAGS 
                       1                        2                        1 
</r:output>
</r:code>
And this only has two unique values.  
And most of the values are 1 and 2:
<r:code>
table(unlist(sapply(edefs[is.na(w)], function(x) x@values)))
<r:output>
 1  2 32 64 
18 15  1  1 
</r:output>
</r:code>
The values 32 and 64 are powers of 2 and could well indicate a bitwise
value.  That is wxRE_NOTBOL and wxRE_NOTEOL and these refer to
not-beginning-of-line and not-end-of-line.  These two may well be
bitwise as it is reasonable to AND or OR them together.  However, it
looks like the definitions that this function was unable to guess are
not bitwise enumerations, or more precisely, it is not vital that we
treat them as bitwise enumerations.
</para>

<para>
Of course, we should check for false positives false negatives in our
guessing.  The ones it thought were bitwise elements are
<r:code>
names(edefs[w])
<r:output>
  [1] "wxStreamError"             "._186"                    
  [3] "wxFileKind"                "wxKeyType"                
  [5] "wxSeekMode"                "wxPathFormat"             
  [7] "Country"                   "stripType"                
  [9] "wxKeyType"                 "wxStreamError"            
 [11] "wxZipFlags"                "WeekDay"                  
 [13] "._40"                      "wxBackgroundStyle"        
 [15] "wxBorder"                  "wxWindowVariant"          
 [17] NA                          "wxBackgroundStyle"        
 [19] "WeekFlags"                 "._102"                    
 [21] "wxUpdateUI"                NA                         
 [23] "_Ios_Fmtflags"             "wxWindowVariant"          
 [25] "._108"                     "_Ios_Fmtflags"            
 [27] "OpenMode"                  "wxDragResult"             
 [29] "event"                     "_Ios_Iostate"             
 [31] "wxClientDataType"          "wxHTTP_Req"               
 [33] "Direction"                 "wxHtmlOpeningStatus"      
 [35] "wxURLError"                "_Ios_Iostate"             
 [37] "wxProtocolError"           "wxEdge"                   
 [39] "_Ios_Openmode"             "wxRelationship"           
 [41] "wxOrientation"             "wxZipAttributes"          
 [43] "_Ios_Openmode"             "wxEOL"                    
 [45] "wxSocketType"              "wxURLError"               
 [47] "._170"                     "wxURIHostType"            
 [49] "Addr"                      "wxRegionOp"               
 [51] NA                          "_Ios_Seekdir"             
 [53] "wxStringTokenizerMode"     "wxPrintMode"              
 [55] "_Ios_Seekdir"              "._104"                    
 [57] "wxItemKind"                "._118"                    
 [59] "wxRegionContain"           "._101"                    
 [61] "._96"                      "._99"                     
 [63] "wxDataFormatId"            "._94"                     
 [65] "GAddressType"              NA                         
 [67] NA                          "_LIB_VERSION_TYPE"        
 [69] "wxDuplexMode"              NA                         
 [71] "wxURIFieldType"            "._105"                    
 [73] "._133"                     "wxURIHostType"            
 [75] "__socket_type"             NA                         
 [77] "._163"                     "._110"                    
 [79] "._6"                       "wxCalendarDateBorder"     
 [81] "wxFlexSizerGrowMode"       "wxStringTokenizerMode"    
 [83] "GSocketEvent"              NA                         
 [85] "wxItemKind"                "wxCheckBoxState"          
 [87] "wxEdge"                    "wxCalendarHitTestResult"  
 [89] "._169"                     "._146"                    
 [91] "wxMailcapStyle"            "wxLocaleCategory"         
 [93] "wxZipMethod"               "._126"                    
 [95] "WeekDay"                   "._117"                    
 [97] "wxDirection"               "wxSocketNotify"           
 [99] "._131"                     "wxIPCFormat"              
[101] "._134"                     "wxDataFormatId"           
[103] "result"                    "iconId_Type"              
[105] "._145"                     "wxToolBarToolStyle"       
[107] "wxHtmlSelectionState"      "dateorder"                
[109] "part"                      "wxSocketType"             
[111] "._115"                     "wxBatteryState"           
[113] "_wxArraywxArrayLinesType"  "wxKillError"              
[115] "wxHtmlURLType"             "wxTextFileType"           
[117] "._144"                     "_wxArraywxArrayLinesType" 
[119] "__codecvt_result"          "wxPowerType"              
[121] "EntryType"                 "wxLayoutAlignment"        
[123] "._179"                     NA                         
[125] "._59"                      "._98"                     
[127] "._118"                     "._125"                    
[129] "wxPathNormalize"           "part"                     
[131] "part"                      "._127"                    
[133] "part"                      "part"                     
[135] "._168"                     "._91"                     
[137] "wxTextFileType"            "BufMode"                  
[139] "wxSystemScreenType"        "._124"                    
[141] NA                          "._155"                    
[143] "wxCmdLineEntryType"        "wxClientDataType"         
[145] NA                          "._166"                    
[147] "wxListColumnFormat"        NA                         
[149] "wxSashEdgePosition"        "._177"                    
[151] "wxCmdLineParamType"        "._122"                    
[153] "wxTextAttrAlignment"       "._121"                    
[155] "wxSashEdgePosition"        "wxLayoutAlignment"        
[157] "wxCalendarDateBorder"      "fmtflags"                 
[159] "wxTreeItemIcon"            "._120"                    
[161] "wxSocketNotify"            "fmtflags"                 
[163] "._141"                     "wxOutCode"                
[165] "._164"                     "wxGridSelectionModes"     
[167] "._139"                     "wxAttrKind"               
[169] "CursorMode"                "wxFindReplaceDialogStyles"
[171] "wxFindReplaceFlags"        "float_round_style"        
[173] "wxPrinterError"            "._136"                    
[175] NA                          "wxHtmlSelectionState"     
[177] "wxDLFlags"                 "._19"                     
[179] "wxAlignment"               "float_round_style"        
[181] "._152"                     "._148"                    
[183] "wxTextAttrAlignment"       "._48"                     
[185] NA                          "._47"                     
[187] NA                          "._45"                     
[189] NA                          "._135"                    
[191] "._140"                     "wxDuplexMode"             
[193] "wxPrintMode"               "wxStretch"                
[195] NA                          "fileListFieldType"        
[197] "fileType"                  "._18"                     
[199] "wxFlexSizerGrowMode"       "fileListFieldType"        
</r:output>
</r:code>
The <r:na/>'s indicate that we don't know the name of this
enumeration, i.e.  it is anonymous.  Also, some of the named
enumerations come from the system files, not wxWidgets as we did not
filter on the file names.
</para>
<para>
We can look at the values with commands such as
<r:code>
edefs[["fileType"]]@values
<r:output>
 is_file   is_dir  is_link   is_exe is_drive 
       0        1        2        4        8 
</r:output>
</r:code>
</para>

<note><para>computeGlobalEnumConstants now returns a list of EnumerationDefinition
objects and we work from that. 
</para></note>
<r:frag id="globals">
anonEnums = computeGlobalEnumConstants(tu, files = targetFiles)
writeCode(anonEnums, "r", file = file.path(autoGenerateDir, "../R/anonEnums.R"))
</r:frag>

<para>
<r:frag id="globals">
z = getDefines(".*", dir = "/usr/local/include/wx-2.6/wx")

dd = names(z)[duplicated(names(z))]
dups = lapply(dd, function(id)  z[names(z) == id])
dups = dups[sapply(dups, function(x) length(unique(x))) > 1]
</r:frag>
</para>

<para>
The following are taken from constants.xml in the doc/
directory of the RGCCTranslationUnit package.

<note><para>
This has already been done, but slightly different.
When we review this document we should consolidate.
</para></note>
<r:frag id="globals">
enums = getEnumerations(tu, wxFiles, NULL)
enumDefs = computeGlobalEnumConstants(tu, enums, defs = types)

q = getCppDefines("~/Projects/org/omegahat/R/RwxWidgets/src/wxAll.h", "`wx-config --cflags`")
qq = processDefines(q, keepFlags = TRUE, headerIfDefPattern = "(^__|(^__?[_A-Z]+__|_H_{,2}|_H_BASE_)$)")
</r:frag>

And here we write out the macros definitions to wxMacros.R.
<r:frag id="globals">
wxMacros.R = paste(autoGenerateDir, "..", "R", "wxMacros.R", sep = .Platform$file.sep)
con = file(wxMacros.R, "w")
code = sapply(names(qq$macros), function(id) paste("`", id, "`",  " = ", qq$macros[id], sep = ""))
cat(code, "\n", sep = "\n", file = con)
close(con)
</r:frag>

And the macros we have to calculate in C code 
<r:frag id="globals"><![CDATA[
# Generate the C code that generates the R code defining the 
# variables in qq$calculate
wxDefines.cpp = paste(autoGenerateDir, "..", "inst", "src", "wxDefines.cpp", sep = .Platform$file.sep)
cdefs = file(wxDefines.cpp, "w")
cat("#include <stdio.h>",
    '#include "wxAll.h"',
    "int",
    "main(int argc, char *argv[])",
    "{",
    sep = "\n", file = cdefs)

invisible(
sapply(names(qq$calculate),
       function(id) {
          cat('printf("`', id, '` = %d\\n", (int) ', qq$calculate[id], ');\n', sep = "", file = cdefs)
       }))

cat("return(0);",
    "}\n", sep = "\n", file = cdefs)
close(cdefs)
]]></r:frag>

</para>

<para>
Now we have amassed the material to generate the interface.
We check if the variable NoOutput is defined and, if it is, whether it is FALSE.
If so, the we don't generate the output and we are done.
Otherwise, we write the C and R code to the relevant files.
<r:code>
if(!exists("NoOutput") || !NoOutput) {

<r:code ref="globals" />

<![CDATA[
# Dynamic casting from generic instance to specific.
# Both R and C++ code: setAs() in R and wxDynamicCast(x, type) in C++
do_wxDynamicCast =
  # For use with wxWidgets
function(var, className, target)
   paste(target, "=", "wxDynamicCast(", var, ", ", className, ");")

casts = lapply(widgetClasses, createDynamicCastCode, do_wxDynamicCast, "wxObject")


#XX Derived classes

# Want code in C/R that creates R variables with the constant primitive values.
#
con = file("tmp/RwxBindings.cpp", "w")
writeIncludes(c("<wx/wx.h>", "<wx/html/htmlwin.h>", "<Rinternals.h>", "<Rdefines.h>",
                '"RwxUtils.h"', '"Rwxdecl.h"'), con)

sapply(classBindings, writeCode, "native", file = con)
close(con)

con = file("tmp/RwxBindings.R", "w")
sapply(classBindings, writeCode, "r", file = con)
close(con)


RconversionRoutines = objects(helperInfo)
decls = sapply(RconversionRoutines,
                  function(id) {
                    obj = get(id, helperInfo)[[1]]
                    d = getNativeDeclaration("", PointerType(obj), addSemiColon = FALSE)
                     # Watch for duplicate constants. Can do this by looking at the qualifiers
                     # slot, but do it this way for the moment.
                    if(length(grep("^const", d)) == 0)
                      d = paste("const", d)
                    decl = paste("SEXP", id, "(",  d, ");")
                  })
declCon = file("Rwxdecl.h", "w")
cat(paste(decls, "\n"), file = declCon)
close(declCon)
}
]]>
</r:code>
</para>


<section>
<title>Creating the tu file</title>

<para>
We found out that, at least for certain versions of g++, we are not
getting the class definitions by simply including the header files,
but rather we have to have instances of the classes.  For classes that
are referenced in the header files, e.g. types for a static field, the
information is generated in the TU file.
Is it enough merely to be a base class? 
</para>
<para>
Regardless, we can get around this problem
by adding  lines of the form
wxGridBagSizer  _wxGridBagSizer;
to our wx.cpp file.
We need to identify all the classes.

<r:code eval="false">
classDefs = system("grep -rh '^class' /usr/local/include/wx-2.6/wx", intern = TRUE)
classDefs = classDefs[ - grep("#", classDefs) ]
classDefs = classDefs[ - grep("^class ?(exp)? (name|cls)", classDefs) ]
#classDefs = classDefs[ - grep("^class name", classDefs) ]

classDefs = gsub("//.*","", classDefs)
classDefs = gsub("\\\\","", classDefs)
tmp = gsub("^class\\s*(WXDLLEXPORT|WXDLLIMPEXP|WXDLLIMPEXP_BASE|WXDLLIMPEXP_XML|WXDLLEXPORT_CORE|WXDLLIMPEXP_CORE|WXDLLIMPEXP_ADV|WXDLLIMPEXP_NET|WXDLLIMPEXP_DBGRID|WXDLLIMPEXP_ODBC|WXDLLIMPEXP_HTML|WXDLLIMPEXP_MEDIA|WXDLLIMPEXP_QA|WXDLLIMPEXP_GL|WXDLLIMPEXP_XRC)\\s* ", "", classDefs, perl = TRUE)

tmp1 = gsub("(;|:|\\{).*$", "", tmp)
tmp1 = gsub("^class", "", tmp1)
classNames = gsub("^\\s(.*)\\s*", "\\1", tmp1, perl = TRUE)

n = sapply(strsplit(classNames, "[ \t]+"), length)
classNames[n > 1]
</r:code>

An alternative approach is to generate the 
class hierarchy dump information.
Using the original wx.cpp file, we
run
<sh:code>
g++ -DNO_WX_VARS=1 -fdump-class-hierarchy -c -o /dev/null wx.cpp `wx-config --cflags` 
</sh:code>
And then get the class information with
<r:code>
classNames = gsub("^Vtable for ", "", system("grep 'Vtable for' wx.cpp.t01.class", intern = TRUE))
</r:code>

<r:code>
cat(paste(classNames, paste("_", classNames, sep = ""), ";\n"),  file = "wxVars.cpp")
</r:code>
</para>
</section>

<section>
<title>Examples of Working with Code Description Objects</title>


<section><title>Finding methods with a particular return type</title>
Suppose we wanted to answer the question what method returns a
wxMBConv object?  We have the resolved methods in wxRMethods.
<r:code><![CDATA[
i = sapply(wxRMethods,
            function(x) {
                 sapply(x, function(m) !is.na(m$returnType@name) && m$returnType@name == "wxMBConv")
            })     

which(sapply(i, any))
]]><r:output>
wxArchiveClassFactory 
                    2 
</r:output>
</r:code>
So we can fetch the actual method with
<r:code>
o = wxRMethods[[2]][ i[[2]] ][[1]]
o$name
</r:code>
So the method that returns a reference to an abstract class wxMBConv is
wxArchiveClassFactor::GetConv.
Every other method that returns a reference to or an actual C++ instance
involves an object that can be  copied using 
<cpp:code>
  Type *ptr, ans;
  ans = fun(...);
  ptr = new Type();
  *ptr = ans;
</cpp:code>
</section>

<section>
<title>Finding all Methods with a particular name</title>
<para>
Suppose we want to find the Add methods across all the classes.
<r:code>
addMethods = unlist(lapply(wxRMethods, function(x) x[names(x) == "Add"]), recursive = FALSE)
length(addMethods)
sapply(addMethods, class)
</r:code>

To see what classes these come from, 
<r:code>
table(gsub("\\..*$", "", names(addMethods)))
<r:output>
wxAcceleratorTable         wxFileCtrl     wxGridBagSizer            wxSizer 
                 1                  1                  8                  6 
</r:output>
</r:code>

What is the class hierarchy for these?
<r:code>
classNames = unique(gsub("\\..*$", "", names(addMethods)))
sapply(classNames,  function(i) getBaseClasses(wxClasses[[i]], recursive = TRUE))
<r:output>
$wxSizer
                    624                   20999 
             "wxObject" "wxClientDataContainer" 

$wxAcceleratorTable
       624 
"wxObject" 

$wxGridBagSizer
                 461390                  461555                   18543 
      "wxFlexGridSizer"           "wxGridSizer"               "wxSizer" 
                    624                   20999 
             "wxObject" "wxClientDataContainer" 

$wxFileCtrl
             263671              265806               16291               18625 
       "wxListCtrl" "wxGenericListCtrl"         "wxControl"     "wxControlBase" 
               7157                8565                7585                 624 
         "wxWindow"      "wxWindowBase"      "wxEvtHandler"          "wxObject" 
</r:output>
</r:code>
</para>
</section>

<section>
<title>Finding polymorphic methods</title>
<para>
Here we want to find the names (and associated classes) of methods
that are either a) polymorphic and/or b) virtual (i.e. inherited
across classes).


</para>
</section>
</section>


<section><title>Finding the instances of C++ classes returned directly (not as references)</title>
<para>
Having run createClassBindings on wxClasses, we currently get lots of 
messages from convertValueToR and convertRValue
as it is being conservative about copying C++ instances
and not pointers.  So we want to investigate these.
If we grab all the warning messages from the console
and put them in a file, then we can find the names of the
classes involved.
<r:code>
ll = readLines("/tmp/bb")
e = unique(gsub(".* ", "", ll[seq(2, by = 2, length = 50)]))
cat(sapply(e, function(e) paste("{", e, "*a, obj;  a = new ", e, "(); *a = obj; }")), sep = "\n")
</r:code>
</para>
</section>

</article>
